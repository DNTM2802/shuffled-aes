from array import array
from copy import copy
import hashlib
from random_round import random_number, shuffle_array
import time

##### CONSTANTS #####

# Substitution Box
s_box = [
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
]

# Inverse Substitution Box
inv_s_box = [
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
]

# Permutations for Shuffle Shift Rows
permutations = [
    (0,1,2,3),
    (0,1,3,2),
    (0,2,1,3),
    (0,2,3,1),
    (0,3,2,1),
    (0,3,1,2),
    (1,0,2,3),
    (1,0,3,2),
    (1,2,0,3),
    (1,2,3,0),
    (1,3,2,0),
    (1,3,0,2),
    (2,1,0,3),
    (2,1,3,0),
    (2,0,1,3),
    (2,0,3,1),
    (2,3,0,1),
    (2,3,1,0),
    (3,1,2,0),
    (3,1,0,2),
    (3,2,1,0),
    (3,2,0,1),
    (3,0,2,1),
    (3,0,1,2),
]

# Rcon for Key Expansion
rcon = (0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36)

##### MODULE VARIABLES #####

# Key and Shuffle Key initialization
key = None
skey = None

# Big pseudo random number generated by Shuffle Key
random_big_number = None

# Pseudo random variables used for Shuffle capabilities
shuffle_round = None
rk_offset = None
mc_offset = None

# Shuffled SBox and respective inverse initialization
s_box_shuffled = []
inv_s_box_shuffled = [-1 for _ in range(256)]



###### AUXILIARY FUNCTIONS ##########

def calc_inv_matrix(inv_matrix, matrix):
    """
    Calculates the inverted matrix of a provided matrix.
    The value of the index of the matrix corresponds to the
    index of the value of the inverse matrix.
    """

    for i in range(256):
        inv_matrix[matrix[i]] = i

def bytes_to_matrix(bytes):
    """
    Converts set of bytes to a 4x4 matrix.
    """

    matrix = []
    for i in range(0, 16, 4):
        matrix.append(list(bytes[i:i+4]))
    return matrix

def ciphered_bytes_to_matrix(bytes):
    """
    Converts set of ciphered bytes to a 4x4 matrix.
    """

    matrix = []
    for i in range(0, 16, 4):
        matrix.append([ord(b) for b in bytes[i:i+4]])
    return matrix

def matrix_to_bytes(matrix):
    """
    Converts a 4x4 matrix to a set of bytes.
    """
    return bytes(sum(matrix, []))


def galoisMult(a, b):
    """
    Galois Multiplication for Mix Column operation, maintaining
    the result inside Galois Field (a number from 0 to 255).
    """

    p = 0
    hiBitSet = 0
    for i in range(8):
        if b & 1 == 1:
            p ^= a
        hiBitSet = a & 0x80
        a <<= 1
        if hiBitSet == 0x80:
            a ^= 0x1b
        b >>= 1
    return p % 256
 
def xor_4_block(array1, array2):
    """
    XORs two blocks.
    """
    
    return list(bytes(i^j for i, j in zip(array1, array2)))

# Code adopted from https://github.com/pelisalacarta-ce/pelisalacarta-ce/blob/master/python/main-classic/lib/jscrypto.py
# <<<
# Multiplication cache tables for Galois Field Operations optimization
gf_mul_by_2  = array('B', [galoisMult(x,  2) for x in range(256)])
gf_mul_by_3  = array('B', [galoisMult(x,  3) for x in range(256)])
gf_mul_by_9  = array('B', [galoisMult(x,  9) for x in range(256)])
gf_mul_by_11 = array('B', [galoisMult(x, 11) for x in range(256)])
gf_mul_by_13 = array('B', [galoisMult(x, 13) for x in range(256)])
gf_mul_by_14 = array('B', [galoisMult(x, 14) for x in range(256)])
# >>>


##### ROUND OPERATIONS ####

def sub_bytes_4(matrix):
    """
    Performs Sub Bytes operation in one dimensional
    matrix of 4 bytes. Uses constant Sub Box matrix.
    """

    for col in range(4):
        matrix[col] = s_box[matrix[col]]

def sub_bytes_4x4_matrix(matrix):
    """
    Performs Sub Bytes operation in two dimensional
    matrix of 4x4 bytes. Uses constant Sub Box matrix.
    """

    for i in range(4):
        for j in range(4):
            matrix[i][j] = s_box[matrix[i][j]]

def sub_bytes_shuffled_4x4_matrix(matrix):
    """
    Performs Sub Bytes operation in two dimensional
    matrix of 4x4 bytes. Uses constant Sub Box Shuffled matrix.
    """

    for i in range(4):
        for j in range(4):
            matrix[i][j] = s_box_shuffled[matrix[i][j]]

def shift_rows(matrix):
    """
    Shift rows operation.
    Row 1 shifts 1 byte, row 2 shifts 2 bytes, row 3 shifts 3 bytes.
    """

    matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1] = matrix[1][1], matrix[2][1], matrix[3][1], matrix[0][1]
    matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2] = matrix[2][2], matrix[3][2], matrix[0][2], matrix[1][2]
    matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3] = matrix[3][3], matrix[0][3], matrix[1][3], matrix[2][3]

def shift_rows_suffled(matrix):
    """
    Shift rows shuffled operation.
    Row 0 shifts a bytes, row 1 shifts b bytes, row 2 shifts c bytes, row 3 shifts d bytes,
    where (a,b,c,d) is a pseudo-randomly chosen permutation from the permutations constant.
    """

    index = int(random_big_number % len(permutations))
    perm = permutations[index]
    
    matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0] = matrix[(perm[0]) % 4][0], matrix[(perm[0] + 1) % 4][0], matrix[(perm[0] + 2) % 4][0], matrix[(perm[0] + 3) % 4][0]
    matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1] = matrix[(perm[1]) % 4][1], matrix[(perm[1] + 1) % 4][1], matrix[(perm[1] + 2) % 4][1], matrix[(perm[1] + 3) % 4][1]
    matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2] = matrix[(perm[2]) % 4][2], matrix[(perm[2] + 1) % 4][2], matrix[(perm[2] + 2) % 4][2], matrix[(perm[2] + 3) % 4][2]
    matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3] = matrix[(perm[3]) % 4][3], matrix[(perm[3] + 1) % 4][3], matrix[(perm[3] + 2) % 4][3], matrix[(perm[3] + 3) % 4][3]


def mix_columns(matrix):
    """
    Mix Columns operation.
    Columns are mixed (XORed) by fixed values resulting from Galois Field multiplication.
    """
    # Code adopted from https://github.com/pelisalacarta-ce/pelisalacarta-ce/blob/master/python/main-classic/lib/jscrypto.py
    # <<<
    global gf_mul_by_2
    global gf_mul_by_3
        
    # Cached global multiplication tables
    mul_by_2 = gf_mul_by_2
    mul_by_3 = gf_mul_by_3

    for i in range(4):
            
        v0, v1, v2, v3 = (matrix[i][0], matrix[i][1], matrix[i][2],matrix[i][3])
        matrix[i][0] = mul_by_2[v0] ^ v3 ^ v2 ^ mul_by_3[v1]
        matrix[i][1] = mul_by_2[v1] ^ v0 ^ v3 ^ mul_by_3[v2]
        matrix[i][2] = mul_by_2[v2] ^ v1 ^ v0 ^ mul_by_3[v3]
        matrix[i][3] = mul_by_2[v3] ^ v2 ^ v1 ^ mul_by_3[v0]
    # >>>

def mix_columns_shuffled(matrix):
    """
    Mix Columns Shuffled operation.
    Columns are mixed (XORed) by fixed values resulting from Galois Field multiplication.
    In the end, the columns are permuted according to the mix columns offset, provided
    by a pseudo random generator seeded by the Shuffle Key.
    """
    # Code adopted from https://github.com/pelisalacarta-ce/pelisalacarta-ce/blob/master/python/main-classic/lib/jscrypto.py
    # <<<
    mul_by_2 = gf_mul_by_2
    mul_by_3 = gf_mul_by_3

    columns = []
    for i in range(4):
        column = matrix[i]
        temp = copy(column)
        v0, v1, v2, v3 = (temp[0], temp[1], temp[2],temp[3])
        column[0] = mul_by_2[v0] ^ v3 ^ v2 ^ mul_by_3[v1]
        column[1] = mul_by_2[v1] ^ v0 ^ v3 ^ mul_by_3[v2]
        column[2] = mul_by_2[v2] ^ v1 ^ v0 ^ mul_by_3[v3]
        column[3] = mul_by_2[v3] ^ v2 ^ v1 ^ mul_by_3[v0]
        columns.append(column)
    # >>>

    for index,column in enumerate(columns):
        matrix[(index+mc_offset) % 4] = column
    
def inv_sub_bytes_4(matrix):
    """
    Performs Inverse Sub Bytes operation in one dimensional
    matrix of 4 bytes. Uses constant Inverse Sub Box matrix.
    """

    for col in range(4):
        matrix[col] = inv_s_box[matrix[col]]

def inv_sub_bytes_4x4_matrix(matrix):
    """
    Performs Inverse Sub Bytes operation in two dimensional
    matrix of 4x4 bytes. Uses constant Inverse Sub Box matrix.
    """

    for i in range(4):
        for j in range(4):
            matrix[i][j] = inv_s_box[matrix[i][j]]

def inv_sub_bytes_shuffled_4x4_matrix(matrix):
    """
    Performs Inverse Sub Bytes operation in two dimensional
    matrix of 4x4 bytes. Uses constant Inverse Sub Box Shuffled matrix.
    """

    for i in range(4):
        for j in range(4):
            matrix[i][j] = inv_s_box_shuffled[matrix[i][j]]

def inv_shift_rows(matrix):
    """
    Inverse Shift rows operation.
    Row 1 unshifts 1 byte, row 2 unshifts 2 bytes, row 3 unshifts 3 bytes.
    """

    matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1] = matrix[3][1], matrix[0][1], matrix[1][1], matrix[2][1]
    matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2] = matrix[2][2], matrix[3][2], matrix[0][2], matrix[1][2]
    matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3] = matrix[1][3], matrix[2][3], matrix[3][3], matrix[0][3]

def inv_shift_rows_shuffled(matrix):
    """
    Shift rows shuffled operation.
    Row 0 unshifts a bytes, row 1 unshifts b bytes, row 2 unshifts c bytes, row 3 unshifts d bytes,
    where (a,b,c,d) is a pseudo-randomly chosen permutation from the permutations constant.
    """

    index = int(random_big_number % len(permutations))
    perm = permutations[index]

    matrix[(perm[0]) % 4][0], matrix[(perm[0] + 1) % 4][0], matrix[(perm[0] + 2) % 4][0], matrix[(perm[0] + 3) % 4][0] = matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0]
    matrix[(perm[1]) % 4][1], matrix[(perm[1] + 1) % 4][1], matrix[(perm[1] + 2) % 4][1], matrix[(perm[1] + 3) % 4][1] = matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1]
    matrix[(perm[2]) % 4][2], matrix[(perm[2] + 1) % 4][2], matrix[(perm[2] + 2) % 4][2], matrix[(perm[2] + 3) % 4][2] = matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2]
    matrix[(perm[3]) % 4][3], matrix[(perm[3] + 1) % 4][3], matrix[(perm[3] + 2) % 4][3], matrix[(perm[3] + 3) % 4][3] = matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]

def inv_mix_columns_shuffled(matrix):
    """
    Inverse Mix Columns Shuffled operation.
    Columns are mixed (XORed) by fixed values resulting from Galois Field multiplication.
    In the end, the columns are permuted according to the mix columns offset, provided
    by a pseudo random generator seeded by the Shuffle Key.
    """

    # Code adopted from https://github.com/pelisalacarta-ce/pelisalacarta-ce/blob/master/python/main-classic/lib/jscrypto.py
    # <<<
    mul_9  = gf_mul_by_9
    mul_11 = gf_mul_by_11
    mul_13 = gf_mul_by_13
    mul_14 = gf_mul_by_14

    columns = []
    for i in range(4):
        column = matrix[i]
        temp = copy(column)
        v0, v1, v2, v3 = (temp[0], temp[1], temp[2],temp[3])

        column[0] = mul_14[v0] ^ mul_9[v3] ^ mul_13[v2] ^ mul_11[v1]
        column[1] = mul_14[v1] ^ mul_9[v0] ^ mul_13[v3] ^ mul_11[v2]
        column[2] = mul_14[v2] ^ mul_9[v1] ^ mul_13[v0] ^ mul_11[v3]
        column[3] = mul_14[v3] ^ mul_9[v2] ^ mul_13[v1] ^ mul_11[v0]
        columns.append(column)
    # >>>
    
    for index,column in enumerate(columns):
        matrix[(index+(mc_offset if mc_offset == 2 or mc_offset == 0 else mc_offset - 2)) % 4] = column

def inv_mix_columns(matrix):
    """
    Inverse Mix Columns operation.
    Columns are mixed (XORed) by fixed values resulting from Galois Field multiplication.
    """

    # Code adopted from https://github.com/pelisalacarta-ce/pelisalacarta-ce/blob/master/python/main-classic/lib/jscrypto.py
    # <<<
    mul_9  = gf_mul_by_9
    mul_11 = gf_mul_by_11
    mul_13 = gf_mul_by_13
    mul_14 = gf_mul_by_14

    for i in range(4):

        v0, v1, v2, v3 = (matrix[i][0], matrix[i][1], matrix[i][2], matrix[i][3])

        matrix[i][0] = mul_14[v0] ^ mul_9[v3] ^ mul_13[v2] ^ mul_11[v1]
        matrix[i][1] = mul_14[v1] ^ mul_9[v0] ^ mul_13[v3] ^ mul_11[v2]
        matrix[i][2] = mul_14[v2] ^ mul_9[v1] ^ mul_13[v0] ^ mul_11[v3]
        matrix[i][3] = mul_14[v3] ^ mul_9[v2] ^ mul_13[v1] ^ mul_11[v0]
    # >>>


def add_round_key(matrix, key):
    """
    Add Round Key operation.
    A 4x4 matrix is XORed with the correspondent key.
    """

    for i in range(4):
        for j in range(4):
            matrix[i][j] ^= key[i][j]
    

def add_round_key_shuffle(matrix, key):
    """
    Add Round Key Shuffle operation.
    A 4x4 matrix is XORed with the correspondent offseted key.
    The offset is provided by a pseudo random generator seeded by the Shuffle Key.
    """

    for i in range(4):
        for j in range(4):
            matrix[i][j] ^= key[i][(j+rk_offset) % 4]


#### KEY EXPANSION ####

def expand_key(key):
    """
    Performs key expansion, in which 1 key of 16 bytes is expanded into
    11 keys of 176 bytes (total).
    """
    
    rcon_index = 0
    for i in range(4,44):
        new_column = []
        if i % 4 == 0:

            # Rotation
            new_column = [key[i-1][1],key[i-1][2],key[i-1][3],key[i-1][0]]

            # Sub Bytes
            sub_bytes_4(new_column)

            # XOR with Rcon
            new_column[0] ^= rcon[rcon_index]
            rcon_index+=1
        
            # XOR with previous (i-1) block
            new_column = xor_4_block(new_column, key[i-4])

        else:
            new_column = xor_4_block(key[i-4], key[i-1])

        key.append(new_column)


#### Padding ####

def padding_pkcs7(plain):
    """
    Adds PKCS7 padding to given bytes.
    """

    padding_len = 16 - (len(plain) % 16)
    return plain + bytes([padding_len] * padding_len)

def remove_padding_pkcs7(plain_padded):
    """
    Removes PKCS7 padding from given bytes.
    """

    return plain_padded[:16-plain_padded[-1]]


#### BLOCK OPERATIONS ####

def aes_encrypt_block(block):
    """
    Standart AES Block Encryption.
    Recieves a 16 byte block of plain, encrypts it using 176 byte key and returns
    a 16 byte block of cipher.
    """

    # Get workable matrix
    matrix = bytes_to_matrix(block)

    # Add first round key (add first round key ->)
    add_round_key(matrix, key[0:4])

    # Flux adjustment because of special rounds (-> sub bytes -> shift rows ->)
    sub_bytes_4x4_matrix(matrix)
    shift_rows(matrix)

    # 9 normal rounds (-> mix columns -> add round key -> subbytes -> shift rows ->)
    for i in range(1,10):
        mix_columns(matrix)
        add_round_key(matrix, key[4*i:4*i+4])
        sub_bytes_4x4_matrix(matrix)
        shift_rows(matrix)  
            
    # Last round (just round key because of flux adjustment) (-> add last round key)
    add_round_key(matrix, key[40:44])

    return matrix_to_bytes(matrix)

def saes_encrypt_block(block):
    """
    SAES Block Encryption.
    Recieves a 16 byte block of plain, encrypts it using 176 byte key and returns
    a 16 byte block of cipher.
    Performs shuffled operations in one of the 9 complete rounds.
    """

    # Get workable matrix
    matrix = bytes_to_matrix(block)

    # Add first round key (add first round key ->)
    add_round_key(matrix, key[0:4])

    # Flux adjustment because of special rounds (-> sub bytes -> shift rows ->)
    sub_bytes_4x4_matrix(matrix)
    shift_rows(matrix)

    # 9 normal rounds (-> mix columns -> add round key -> subbytes -> shift rows ->)
    for i in range(1,10):
        # Shuffle round
        if i == shuffle_round:
            mix_columns_shuffled(matrix)
            add_round_key_shuffle(matrix, key[4*i:4*i+4])
            sub_bytes_shuffled_4x4_matrix(matrix)
            shift_rows_suffled(matrix)
        # Normal round
        else:
            mix_columns(matrix)
            add_round_key(matrix, key[4*i:4*i+4])
            sub_bytes_4x4_matrix(matrix)
            shift_rows(matrix)
            
            
    # Last round (just round key because of flux adjustment) (-> add last round key)
    add_round_key(matrix, key[40:44])

    return matrix_to_bytes(matrix)



def saes_decrypt_block(block):
    """
    SAES Block Decryption.
    Recieves a 16 byte block of cipher, decrypts it using 176 byte key and returns
    a 16 byte block of plain.
    Performs shuffled operations in one of the 9 complete rounds.
    """

    # Get workable matrix
    matrix = ciphered_bytes_to_matrix(block)

    # Add first (aka last) round key ( <- add last round key)
    add_round_key(matrix, key[40:44])

    # 9 normal rounds ( <- inv mix columns <- add round key <- inv subbytes <- inv shift rows <-)
    for i in range(9,0,-1):
        if i == shuffle_round:
            inv_shift_rows_shuffled(matrix)
            inv_sub_bytes_shuffled_4x4_matrix(matrix)
            add_round_key_shuffle(matrix, key[4*i:4*i+4])
            inv_mix_columns_shuffled(matrix)
        else:
            inv_shift_rows(matrix)
            inv_sub_bytes_4x4_matrix(matrix)
            add_round_key(matrix, key[4*i:4*i+4])
            inv_mix_columns(matrix)

    # Last round (add first round key <- inv sub bytes <- inv shift rows <-)
    inv_shift_rows(matrix)
    inv_sub_bytes_4x4_matrix(matrix)
    add_round_key(matrix, key[0:4])

    return matrix_to_bytes(matrix)

def aes_decrypt_block(block):
    """
    Standart AES Block Decryption.
    Recieves a 16 byte block of cipher, decrypts it using 176 byte key and returns
    a 16 byte block of plain.
    """

    # Get workable matrix
    matrix = ciphered_bytes_to_matrix(block)

    # Add first (aka last) round key ( <- add last round key)
    add_round_key(matrix, key[40:44])

    # 9 normal rounds ( <- inv mix columns <- add round key <- inv subbytes <- inv shift rows <-)
    for i in range(9,0,-1):
        inv_shift_rows(matrix)
        inv_sub_bytes_4x4_matrix(matrix)
        add_round_key(matrix, key[4*i:4*i+4])
        inv_mix_columns(matrix)

    # Last round (add first round key <- inv sub bytes <- inv shift rows <-)
    inv_shift_rows(matrix)
    inv_sub_bytes_4x4_matrix(matrix)
    add_round_key(matrix, key[0:4])

    return matrix_to_bytes(matrix)


#### ENCRYPTION / DECRYPTION MAIN METHODS ####

def saes_encrypt(plain, encryption_key, shuffle_key=None, timeit=False):
    """
    SAES Encryption.
    Performs SAES plain encryption based on an encryption key.
    Given a Shuffle key, performs SAES operations, otherwise
    performs standard AES operations.
    Writes [padding + blocks encryption] elapsed time into a file
    in the same directory if timeit flag is given.
    """

    global key
    global skey

    global shuffle_round
    global rk_offset
    global mc_offset
    global s_box_shuffled
    global random_big_number

    start = None
    end = None
    time_file = None

    # Initialize given key
    key = hashlib.md5(bytes(encryption_key, encoding='utf8')).digest()

    # Permorm shuffle mode procedures
    if shuffle_key:
        # Initialize given skey
        skey = hashlib.md5(bytes(shuffle_key, encoding='utf8')).digest()

        # Get a big number dependent of the skey
        random_big_number = random_number(skey)

        # Get random round
        shuffle_round = int((random_big_number % 9) + 1)

        # Shuffle s box
        s_box_shuffled = s_box.copy()
        shuffle_array(s_box_shuffled,random_big_number)

        # Get offset for round key and mix columns
        rk_offset = int(random_big_number % 16)
        mc_offset = int(random_big_number % 4)

        # Tranform bytes into useful matrix
        skey = bytes_to_matrix(skey)
    
    # Tranform bytes into useful matrix
    key = bytes_to_matrix(key)
    
    # Perform key expansion (1 key 16 bytes -> 11 keys 176 bytes)
    expand_key(key)

    # If timeit flag given, start counting time
    if timeit:
        start = time.time_ns()

    # Perform padding on given plain text
    plain = padding_pkcs7(plain.encode('utf8'))

    # ENCRYPTION
    
    # Shuffled encryption
    if skey:
        # For each 16 byte block
        for i in range(0,len(plain), 16):
            block = plain[i:i+16]
            cipher_block = saes_encrypt_block(block)

            # Stdout block
            for b in cipher_block:
                print(chr(b),end="")
    
    # Normal encryption
    else:
        # For each 16 byte block
        for i in range(0,len(plain), 16):
            block = plain[i:i+16]
            cipher_block = aes_encrypt_block(block)

            # Stdout block
            for b in cipher_block:
                print(chr(b),end="")
    
    # Write elapsed time to a file
    if timeit:
        end = time.time_ns()
        time_file = open(f'times/self-{"saes" if skey else "aes"}_encrypt_times.txt', 'a')
        overall = (end - start) / (10 ** 9)
        time_file.write(str(overall)+"\n")


def saes_decrypt(cipher, decryption_key, shuffle_key=None, timeit=False):
    """
    SAES Decryption.
    Performs SAES cipher decryption based on an decryption key.
    Given a Shuffle key, performs SAES operations, otherwise
    performs standard AES operations.
    Writes [blocks decryption + padding removal] elapsed time into a
    file in the same directory if timeit flag is given.
    """

    global key
    global skey

    global shuffle_round
    global mc_offset
    global rk_offset
    global inv_s_box_shuffled
    global random_big_number

    start = None
    end = None
    time_file = None

    # Initialize given key
    key = hashlib.md5(bytes(decryption_key, encoding='utf8')).digest()

    # Permorm shuffle mode procedures
    if shuffle_key:

        # Initialize given skey
        skey = hashlib.md5(bytes(shuffle_key, encoding='utf8')).digest()

        # Get a big number dependent of the skey
        random_big_number = random_number(skey)

        # Get random round
        shuffle_round = int((random_big_number % 9) + 1)

        # Shuffle s box and calc inv s box shuffled
        s_box_shuffled = s_box.copy()
        shuffle_array(s_box_shuffled,random_big_number)
        calc_inv_matrix(inv_s_box_shuffled, s_box_shuffled)

        # Get offset for round key and mix columns
        rk_offset = int(random_big_number % 16)
        mc_offset = int(random_big_number % 4)

        # Tranform bytes into useful matrix
        skey = bytes_to_matrix(skey)
    
    # Tranform bytes into useful matrix
    key = bytes_to_matrix(key)
    
    # Perform key expansion (1 key 16 bytes -> 11 keys 176 bytes)
    expand_key(key)

    # DECRYPTION

    # If flag is given, starts counting time
    if timeit:
        start = time.time_ns()

    # Shuffle decryption
    if skey:
        # For each 16 byte block
        for i in range(0,len(cipher), 16):
            block = cipher[i:i+16]
            plain_block = saes_decrypt_block(block)

            # Last block -> remove padding
            if i + 16 == len(cipher):
                plain_block = remove_padding_pkcs7(plain_block)
            
            # Stdout block
            for c in plain_block:
                print(chr(c), end="")
    
    # Normal decryption
    else:

        # For each 16 byte block
        cipher = cipher[:len(cipher)-len(cipher) % 16]
        for i in range(0,len(cipher), 16):
            
            block = cipher[i:i+16]
            plain_block = aes_decrypt_block(block)

            # Last block -> remove padding
            if i + 16 == len(cipher):
                plain_block = remove_padding_pkcs7(plain_block)
            
            # Stdout block
            for c in plain_block:
                print(chr(c), end="")

    # Write elapsed time to file
    if timeit:
        end = time.time_ns()
        time_file = open(f'times/self-{"saes" if skey else "aes"}_decrypt_times.txt', 'a')
        overall = (end - start) / (10 ** 9)
        time_file.write(str(overall)+"\n")